// ConvexTriangulated.cpp: implementation of the ConvexTriangulated class.
//
//////////////////////////////////////////////////////////////////////

#include "ConvexTriangulated.h"
#include "Facet.h"
#include "jansky.h"
#include "LagerrosLookedup.h"
using namespace std;


ConvexTriangulated::ConvexTriangulated(MikkoFile& mikko, const SpinState& spinAxis,
									   double pv, double H, double G) // default: 0.15
		throw(bad_alloc, invalid_argument)
		: TriangulatedShape(mikko.howManyVertices(), mikko.howManyFacets(),
							pv,
							spinAxis, H, G)
{
	mikko.getVertexArray(vertices.begin()+1, vertices.end());
	mikko.getFacetArray(facets.begin()+1, facets.end());
	TriangulatedShape::calculateIntrinsicDiameter();
}; // ctor(MikkoFile&...)



ConvexTriangulated::ConvexTriangulated(const ObjFile& obj, 
									   const SpinState& spinAxis,
									   double pv, double H, double G) // default: 0.15
												
		throw(bad_alloc, invalid_argument)
		: TriangulatedShape(obj.howManyVertices(), obj.howManyFacets(),
							pv,	spinAxis, H, G)
						
{
	fillArrays(obj);
	TriangulatedShape::calculateIntrinsicDiameter();
}; // ctor(ObjFile, spinAxis, H, G)


/*
ConvexTriangulated::ConvexTriangulated(const ObjFile& obj,
									   double ecl_longitude_axis, double ecl_latitude_axis,
									   double omega, double H, double G)
		throw(bad_alloc, invalid_argument)
		: TriangulatedShape(obj.howManyVertices(), obj.howManyFacets(),
							0.1, 
							eclipticVector(ecl_longitude_axis, ecl_latitude_axis, omega),
							H, G)
{
	fillArrays(obj);
	TriangulatedShape::calculateIntrinsicDiameter();
}; // ctor (ObjFile, double^3, H, G)
*/


void ConvexTriangulated::plotMikkoLC(const char* const filename,
								     double LS, double Lambert,
									 const eclipticVector& Sun2Aster,
									 const eclipticVector& Earth2Aster,
									 const unsigned int plotPoints,
									 unsigned int periods)
									 const
									 throw (invalid_argument)
{
	if (plotPoints<2)
		throw invalid_argument("Error in ConvexTriangulated::plotMikkoLC: there must be at least 2 plotPoints!");
	if (periods==0)
		throw invalid_argument("How should I plot zero periods???");
	ofstream out (filename);
	if (!out)
		throw invalid_argument("Error in ConvexTriangulated::plotMikkoLC: Cannot open file for writing (?)");
	double step = periods/(plotPoints-1.);
	vector3 A2Sun   = bodyFix(Sun2Aster);
	A2Sun *= -1; // unit vector3 pointing away from asteroid
	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;

	double rAU=Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	double factor = bond*scaleFactor*scaleFactor/(vector3::PI*rAU*rAU*deltaKM*deltaKM);
	// 
	// !!!!????????????????????????
	//
	// scaleFactor^2 should correct intrinsic size to km, must be divided by delta(km)
	// unsecure: factors of pi and such
	// now it should be alright!
	// !!!!!!!!!!!!!

	out<<"# Optical lightcurve generated by ConvexTriangulated::plotMikkoLC"<<endl;
	out<<"# Scattering law used: "<<LS<<"*Lommel-Seeliger + "<<Lambert<<"*Lambert."<<endl;
	out<<"# 1st row: time/h (arbitrary offset)"<<endl;
	out<<"# 2nd row: flux in units of the solar constant (normalization unclear, yet)"<<endl;
	out<<"# 3rd row: magnitudes (normalization unclear, too)"<<endl<<endl;

//	out.setf(ios::fixed);
	out.precision(5);
	//out.width(10);
	//out.setf(ios::right);

	double phase = 0;
	for (unsigned int i=0; i<plotPoints; i++)
	{
		double flux=0;
		for (int i=1; i<=nFacets; i++)
			flux+= LS*LSFacet(i, A2Sun, A2Earth) 
				 + Lambert*LambertFacetOptical(i, A2Sun, A2Earth);
		flux*=factor;
		out.setf(ios::fixed); out.width(10);
		out<<phase*period<<"\t";
		out.setf(ios::scientific); out.width(10);
		out<<flux<<"\t";
		out.setf(ios::fixed); out.width(7);
		out<<flux2mag(flux)<<endl;

		spin(A2Sun, step*period);
		spin(A2Earth, step*period);
		phase+=step;
	}

	out.close();
}; // ConvexTriangulated::plotMikkoLC
								


void ConvexTriangulated::plotGeometricLC (const char* const filename,
										  const eclipticVector& Sun2Aster,
										  const eclipticVector& Earth2Aster,
										  const unsigned int plotPoints,
										  unsigned int periods)
										  const
										  throw (invalid_argument)
{
	if (plotPoints<2)
		throw invalid_argument("Error in ConvexTriangulated::plotGeometricLC: there must be at least 2 plotPoints!");
	ofstream out (filename);
	if (!out)
		throw invalid_argument("Error in ConvexTriangulated::plotGeometricLC: Cannot open file for writing (?)");
	double step = periods/(plotPoints-1.);
	vector3 A2Sun   = bodyFix(Sun2Aster);
	A2Sun *= -1; // unit vector3 pointing away from asteroid
	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;

	double rAU=Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	double factor = bond*scaleFactor*scaleFactor/(vector3::PI*rAU*rAU*deltaKM*deltaKM);
	// 
	// !!!!????????????????????????
	//
	// scaleFactor^2 should correct intrinsic size to km, must be divided by delta(km)
	// unsecure: factors of pi and such
	// now it should be alright!
	// !!!!!!!!!!!!!

	out<<"# Optical lightcurve generated by ConvexTriangulated::plotGeometricLC"<<endl;
	out<<"# Scattering law used: geometric scattering."<<endl;
	out<<"# 1st row: time/h (arbitrary offset)"<<endl;
	out<<"# 2nd row: flux in units of the solar constant "<<endl;
	out<<"# 3rd row: flux in magnitudes"<<endl
	   <<"# 4th row: projected area / km^2"<<endl
	   <<endl;

//	out.setf(ios::fixed);
	out.precision(8);
	//out.width(10);
	//out.setf(ios::right);

	double phase = 0;
	for (unsigned int i=0; i<plotPoints; i++)
	{
		double flux=0;
		for (int i=1; i<=nFacets; i++)
			flux+=GeometricFacet(i, A2Sun, A2Earth);
		double projArea = flux*scaleFactor*scaleFactor;
		flux*=factor;
		out.setf(ios::fixed); out.width(10);
		out<<phase*period<<"\t";
		out.setf(ios::scientific); out.width(10);
		out<<flux<<"\t";
		out.setf(ios::fixed); out.width(7);
		out<<flux2mag(flux)<<"\t"
		   <<projArea<<'\n';

		spin(A2Sun, step*period);
		spin(A2Earth, step*period);
		phase+=step;
	}

	out.close();
}; // ConvexTriangulated::plotGeometricLC



// Lombert-Seeliger scattering law
double ConvexTriangulated::LSFacet(int i, vector3 &A2Sun, vector3 &A2Earth) const
{
	const vector3& normal=facets[i]->getDA();

	double cosSunArea=vector3::dot(A2Sun, normal);
	if (cosSunArea<=0)
		return 0; // dA isn't illuminated
	double cosEarthArea=vector3::dot(A2Earth, normal);
	if(cosEarthArea<=0)
		return 0; // dA invisible from Earth
	return cosEarthArea*cosSunArea / (cosEarthArea+cosSunArea);
	// the facet's area enters twice in the numerator, once in the denominator -> OK
}



double ConvexTriangulated::LambertFacetOptical (int i, vector3 &A2Sun, vector3 &A2Earth) const
{
	const vector3& normal=facets[i]->getDA();

	double area=normal.modulus();
	if (area==0)
		return 0;
	
	// cos(angle)*area
	double cosSunArea=vector3::dot(A2Sun, normal);
	if(cosSunArea<0)
		return 0; // dA isn't illuminated
	double cosEarthArea=vector3::dot(A2Earth, normal);
	if(cosEarthArea<0)
		return 0; // dA invisible from Earth
	return cosEarthArea*cosSunArea/area;
}; // ConvexTriangulated::Lambertian Facet



double ConvexTriangulated::GeometricFacet(int i, vector3 &A2Sun, vector3 &A2Earth) const
{
	const vector3& normal=facets[i]->getDA();
	double cosSunArea=vector3::dot(A2Sun, normal);
	if(cosSunArea<=0)
		return 0; // dA isn't illuminated
	double cosEarthArea=vector3::dot(A2Earth, normal);
	if(cosEarthArea<=0)
		return 0; // dA invisible from Earth
	return cosEarthArea;
}; // ConvexTriangulated::GeometricFacet



double ConvexTriangulated::FRMFacet(int facet, 
									const vector3 &A2Sun, const vector3 &A2Earth, 
									double lambdaMu, double rAU) const
{
	const double EPS = 1e-9;
	const vector3& normal=facets[facet]->getDA();
	double projectedArea = vector3::dot(A2Earth, normal);
	if (projectedArea <= 0)
		return 0; // dA invisible from Earth
	double sinSun = A2Sun.getZ();
	double sinNorm= normal.getZ()/normal.modulus();

	double sinsin=sinSun*sinNorm;
	double coscos=sqrt ( (1-sinSun*sinSun)*(1-sinNorm*sinNorm) );

	double f; // average solar cosine
	if (fabs(coscos)<EPS || fabs(sinsin/coscos)>=1)
	{
		if (sinsin>0)
			f= sinsin; // polar summer
		else
			return 0;      // polar winter
	}
	else
	{
		double t0 = acos(-sinsin/coscos);
		f = (sin(t0)*coscos + t0*sinsin)/vector3::PI;
	}

	double T = sqrt(sqrt( AsteroidConstants::solar_over_stefan_boltzmann*(1-bond)*f/(emissivity*rAU*rAU) ));

	double flux=projectedArea;
	flux /= (exp(AsteroidConstants::hck/(lambdaMu*T) ) - 1);
	
	return flux;
};





double ConvexTriangulated::LambertFacet(int facet, 
								const vector3 &A2Sun, const vector3 &A2Earth, 
								double lambdaMu, double rAU) 
								const
{
	const double EPS = 1e-8; // to prevent numeric under/overflow
	const vector3& normal = facets[facet]->getDA();
	double area=normal.modulus();
	if(area==0)
		return 0;
	const vector3 unitNormal = normal/area;

	double cosSun=vector3::dot(A2Sun, unitNormal);
	if (cosSun<EPS)
		return 0; // dA isn't illuminated
	double cosEarth=vector3::dot(A2Earth, unitNormal);
	if (cosEarth<EPS)
		return 0; // dA invisible from Earth

	double T=TSS(rAU, cosSun);		
//		sqrt(sqrt( 
//		AsteroidConstants::solar_over_stefan_boltzmann*(1-bond)*cosSun/rAU/rAU/emissivity   
//		));

	double flux=area*cosEarth;
	flux /= (exp(AsteroidConstants::hck/(lambdaMu*T) ) - 1);
	return flux;
}; // ConvexTriangulated::LambertFacet



void ConvexTriangulated::plotNEATM_POV(const char *const filename, 
									   const eclipticVector &Sun2Aster, 
									   const eclipticVector &Earth2Aster, 
									   double eta, double rotationalPhase, 
									   int nColors) const
									throw(invalid_argument, bad_alloc)
{
	if (eta<=0) 
		throw invalid_argument("ConvexTriangulated::plotNEATM_POV: eta must be positive!");
	ofstream out(filename);
	if (!out)
		throw invalid_argument("ConvexTriangulated::plotNEATM_POV: file couln't be opened!");

	vector3 A2Sun   = bodyFix(Sun2Aster);
	A2Sun *= -1;
	// unit vector3 pointing away from asteroid
	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;

	spin(A2Sun, rotationalPhase*period);
	spin(A2Earth, rotationalPhase*period);

	double rAU= Sun2Aster.getLength();
	double TSS=sqrt(sqrt((1-bond)*AsteroidConstants::solar_over_stefan_boltzmann/(emissivity*eta*pow(rAU,2))));
	nColors;

	double* T     = 0;
	int   * color = 0;
	try
	{
		T = new double [nFacets+1];
		color = new int[nFacets+1];
	}
	catch (bad_alloc& )
	{
		if (T) delete [] T;
		throw;
	};

	{
		double nOverTSS = (nColors-1.) / TSS; // needed in for-loop
		double cosineArea;
		for (int i=1; i<=nFacets; i++)
		{
			cosineArea = A2Sun.dot(facets[i]->getDA());
			if (cosineArea <= 0) 
				T[i] = 0;
			else
				T[i] = TSS * sqrt( sqrt(cosineArea/facets[i]->getDA().modulus()) );
			color[i] = floor(T[i]*nOverTSS + 0.49999999);
			// rounds positive numbers; .4999999 = .5 - eps (to prevent numerical instability)
		};	
	};
	// done with actual calculations, start output

	const int infty=100000;

	out<<"// Plot of the temperature distribution on an asteroid"<<endl;
	out<<"// Programmed by michael.mueller@dlr.de, Jan 07 2004"<<endl<<endl;
	out<<"#include \"colors.inc\""<<endl;
	out<<endl;
	out<<"camera {"<<endl;
	
	const double cameraX = infty*A2Earth.getX();
	const double cameraY = infty*A2Earth.getY();
	const double cameraZ =-infty*A2Earth.getZ();
	// note: all z's are mirrored (POVray uses a left-handed coordinate system!)

	out<<"\tlocation   <"<<cameraX<<", "<<cameraY<<", "<<cameraZ<<">"<<endl;
	out<<"\tlook_at    <0, 0, 0>"<<endl;
	out<<"\tdirection  <"<<-cameraX<<", "
						 <<-cameraY<<", "
						 <<-cameraZ<<">"
						 <<"\t*.75\t//may be helpful when image is clipped"
						 <<endl;
	out<<"}"<<endl;
	out<<"// Camera positioned in Earth's direction at 'infinite' distance"<<endl;
	out<<endl;

	out<<"//light_source {<"<< infty*A2Sun.getX() <<", "
						  << infty*A2Sun.getY() <<", " 
						  <<-infty*A2Sun.getZ() << ">, colour White}"<<endl;
	out<<"// light source in Sun's direction at 'infinite' distance"<<endl;
	out<<"// not illuminated parts are visible, nevertheless"<<endl;
	out<<endl;

/*	out<<"light_source {<0,0,0>, color White}"<<endl;
	out<<endl;
*/

	// BAUSTELLE:
	// rotate all objects back by the rotational phase, about the line of view, that is
	{
		double phi=atan2 (-cameraY, -cameraX);
		double y2=sqrt( cameraX*cameraX + cameraY*cameraY );
		double theta = atan2 (y2, -cameraZ);
		// rotating about x-axis by 90deg - phi and about the new x-axis by theta
		// makes the positive y-axis line of view:

		out<<"#declare phi\t= "<<phi*vector3::RAD<<";"<<endl;
		out<<"#declare theta\t= "<<theta*vector3::RAD<<';'<<endl;
		out<<"#declare rotationalPhase = "<<rotationalPhase<<';'<<endl;
		out<<"#declare rotateBack = transform"<<endl;
		out<<"{"<<endl;
		out<<"\trotate<0,0,90-phi>"<<endl;
		out<<"\trotate<theta-90, 0, 0>\t//line of view is now y-axis"<<endl;
		out<<"\trotate<0,-rotationalPhase*360, 0>\t//here we go!"<<endl;
		out<<"\trotate<90-theta, 0, phi-90>"<<endl;
		out<<"}"<<endl;
		out<<endl;
	}


/*
#declare phi   = 18;
#declare theta = 70;   
#declare rotPhase = 20;
#declare rotateBack = transform
{
   rotate<0,0, phi-90> 
   rotate<theta-90, 0, rotPhase>
   rotate<90-theta, 0, 90-phi>
}
*/ 
      





// mark Cartesian axes:
	out<<"cylinder {"<<endl;
	out<<"\t<-1,0,0>,"<<endl;
	out<<"\t< 1,0,0>,"<<endl;
	out<<"\t.015\t// radius"<<endl;
	out<<"\ttexture {pigment{Green} finish {ambient .8}}"<<endl;
	out<<"\ttransform rotateBack"<<endl;
	out<<"}\t//x-axis  green"<<endl;
	out<<endl;
	out<<"cylinder {"<<endl;
	out<<"\t<0,-1,0>,"<<endl;
	out<<"\t<0, 1,0>,"<<endl;
	out<<"\t.015\t// radius"<<endl;
	out<<"\ttexture {pigment{Yellow} finish {ambient .8}}"<<endl;
	out<<"\ttransform rotateBack"<<endl;
	out<<"}\t//y-axis yellow"<<endl;
	out<<endl;
	out<<"cylinder {"<<endl;
	out<<"\t<0,0,-1>,"<<endl;
	out<<"\t<0,0, 1>,"<<endl;
	out<<"\t.015\t// radius"<<endl;
	out<<"\ttexture {pigment{White} finish {ambient .8}}"<<endl;
	out<<"\ttransform rotateBack"<<endl;
	out<<"}\t//z-axis white"<<endl;
	out<<endl;
	

	out<<"mesh2 {"<<endl;

	out<<"\tvertex_vectors {"<<endl;
	out<<"\t\t"<<nVertices << ", // nVertices"<<endl;
	{
		double dummy=1./intrinsicDiameter; // -> rescale vertices to (more or less) one
		for (int i=1; i<=nVertices; i++)
			out<<"\t\t<"<< ((vector3&)(*vertices[i])).getX()*dummy<<", "
						<< ((vector3&)(*vertices[i])).getY()*dummy<<", "
						<<-((vector3&)(*vertices[i])).getZ()*dummy
						<<">,"<<endl;
			// -z!
	}
	out<<"\t}"<<endl;
	out<<endl;
	// vertices done!

	out<<"\ttexture_list {"<<endl;
	out<<"\t\t"<<nColors<<", // nColors"<<endl;
	{
		double red;
		for (int i=0; i<nColors; i++)
		{
			red=i/(nColors-1.);
			out<<"\t\ttexture {pigment{rgb<"<<red<<", 0, "<<1-red<< ">} finish {ambient .8}},"<<endl;
		}
	};
	out<<"\t}"<<endl;
	out<<endl;
	// colors done!

	out<<"\tface_indices {"<<endl;
	out<<"\t\t"<<nFacets<<", // nFacets"<<endl;
	{
		for (int i=1; i<=nFacets; i++)
		{
			const int* const dummy = facets[i]->getVertices();
			out<<"\t\t<" << dummy[1]-1 <<','  // POV-ray's indices are zero-based!!!
						 << dummy[2]-1 <<','  
						 << dummy[3]-1 <<">, "
						 << color[i] <<','
						 << endl;
		};
	}
	out<<"\t}"<<endl;
	out<<endl;
	// facet indices done!
	
//	out<<"\trotate <0,0,-"<<360.*rotationalPhase<<'>'<<endl;
//  for making movies, only
	out<<"\ttransform rotateBack"<<endl;

	out<<"}"<<endl;
	// everything done!

	delete[] T;
	delete[] color;
} // ConvexTriantulated::plotNEATM_POV



ConvexTriangulated::~ConvexTriangulated() throw()
{}; // dtor



inline void ConvexTriangulated::fillArrays(const ObjFile &obj) throw()
{
	obj.getVertexArray((vertices.begin()+1), vertices.end());
	barycenter2zero();
	obj.getFacetArray(facets.begin()+1, facets.end(), vertices);
}; // ConvexTriangulated::fillArrays(ObjFile&)



void ConvexTriangulated::makeHomFile(const char *const outName, double startJD, 
									 const eclipticVector &Sun2Aster, const eclipticVector &Earth2Aster, 
									 const unsigned int plotPoints)
									 const
{
	ofstream out(outName);
	if(!out)
		throw invalid_argument("Couldn't open output file!");
	vector3 Sun (Sun2Aster);
	vector3 Sun2Earth (Sun);
	Sun2Earth -= Earth2Aster;
	Sun*=1e5;
	Sun2Earth*=1e5;

	double JD=startJD;
	double JDstep= period/(24*plotPoints);

	// BAUSTELLE!
	// no good, yet!!!!!!!!!!!!!
	// edit blanks and decimal places!!!
	// !!!!!!!!!!!!!!!!!!!!!!!!!

	out.setf(ios::fixed);

	for (int i=0; i<plotPoints; i++)
	{
		out.precision(5);
		out<<JD<<"  V 12.8076 0.01T ";
		out.precision(0);
		out<<floor(Sun.getX()+.5)<<" "
		   <<floor(Sun.getY()+.5)<<" "
		   <<floor(Sun.getZ()+.5)<<" " 
		   <<floor(Sun2Earth.getX()+.5)<<" "		   
		   <<floor(Sun2Earth.getY()+.5)<<" "		   
		   <<floor(Sun2Earth.getZ()+.5)<<endl;
		JD+=JDstep;
	}

	out.close();
}; // ConvexTriangulated::makeHomFile



// returns the thermal flux (W/m^2/mu) at lambdaMu WITHOUT craters, thermal inertia or anything
double ConvexTriangulated::LambertFlux (const eclipticVector& Sun2Aster, const eclipticVector& Earth2Aster,
										double JD, double lambdaMu) 
										const
{
	vector3 A2Sun = bodyFix(Sun2Aster, JD);
	A2Sun *= -1;

	vector3 A2Earth = bodyFix(Earth2Aster, JD);
	A2Earth *= -1;

	double rAU=Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	return LambertFlux(A2Sun, A2Earth, lambdaMu, rAU, deltaKM);
};



double ConvexTriangulated::LambertFlux(const vector3 &A2Sun, const vector3 &A2Earth, 
									   double lambdaMu, double rAU, double deltaKM) const
{
	double factor = 2*AsteroidConstants::hc2*emissivity/(pow(deltaKM,2)*pow(lambdaMu, 5)); // prefactor without diameter^2
	factor*=pow(scaleFactor, 2); // this is (diameter/intrinsicDiameter)^2

	double flux=0;
	for (int i=1; i<=nFacets; i++)
		flux+=LambertFacet(i, A2Sun, A2Earth, lambdaMu, rAU);
	flux*=factor;
	
	return flux;
} //ConvexTriangulated::LambertFlux




// returns the thermal flux (W/m^2/mu) at lambdaMu in a NEATM-like fashion
double ConvexTriangulated::NEATMFlux (const eclipticVector& Sun2Aster, const eclipticVector& Earth2Aster,
										double JD, double lambdaMu, double eta) 
										const
{
	vector3 A2Sun = bodyFix(Sun2Aster, JD);
	A2Sun *= -1;

	vector3 A2Earth = bodyFix(Earth2Aster, JD);
	A2Earth *= -1;

	double rAU=Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	return NEATMFlux(A2Sun, A2Earth, lambdaMu, rAU, deltaKM, eta);
}; // ConvexTriangulated::NEATMFlux



double ConvexTriangulated::NEATMFlux(const vector3 &A2Sun, const vector3 &A2Earth, 
									   double lambdaMu, double rAU, double deltaKM, double eta) const
{
	double factor = 2*AsteroidConstants::hc2*emissivity/(pow(deltaKM,2)*pow(lambdaMu, 5)); // prefactor without diameter^2
	factor*=pow(scaleFactor, 2); // this is (diameter/intrinsicDiameter)^2
	double flux=0;
	for (int i=1; i<=nFacets; i++)
		flux+=NEATMFacet(i, A2Sun, A2Earth, lambdaMu, rAU, eta);
	flux*=factor;
	return flux;
}



void ConvexTriangulated::FRMspectrum(int n, const double *const lambdaMu, double *const flux, 
									 const eclipticVector &Sun2Aster, const eclipticVector &Earth2Aster, 
									 double JD) 
									 const
{
	vector3 A2Sun = bodyFix(Sun2Aster);
	A2Sun *= -1;
	spin (A2Sun, 24*(JD-spinAxis.getJD0()));

	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;
	spin (A2Earth, 24.*(JD-spinAxis.getJD0()));
	
	double rAU= Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	{
		for (int i=0; i<n; i++)
		{
			const double& lambda = lambdaMu[i];
			double factor = 2*AsteroidConstants::hc2*emissivity/(pow(deltaKM,2)*pow(lambda, 5)); // prefactor without diameter^2
			factor*=pow(scaleFactor, 2); // this is (diameter/intrinsicDiameter)^2

			flux[i]=0;
			for (int j=1; j<=nFacets; j++)
				flux[i] += FRMFacet(j, A2Sun, A2Earth, lambda, rAU);
			flux[i] *= factor;
		}
	}
}; //ConvexTriangulated::FRMspectrum



double ConvexTriangulated::FRMflux(const eclipticVector &Sun2Aster, const eclipticVector &Earth2Aster, 
								   double JD, double lambdaMu) const
{
	vector3 A2Sun   = bodyFix(Sun2Aster);
	A2Sun *= -1; // unit vector3 pointing away from asteroid at zero time
	spin(A2Sun, 24.*(JD-spinAxis.getJD0())); // rotate frame to JD as given

	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;
	spin (A2Earth, 24.*(JD-spinAxis.getJD0()));
	
	double rAU= Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	return FRMflux (A2Sun, A2Earth, lambdaMu, rAU, deltaKM);
};



double ConvexTriangulated::FRMflux(const vector3 &A2Sun, const vector3 &A2Earth, 
								   double lambdaMu, double rAU, double deltaKM) const
{
	double factor = 2*AsteroidConstants::hc2*emissivity/(pow(deltaKM,2)*pow(lambdaMu, 5)); // prefactor without diameter^2
	factor*=pow(scaleFactor, 2); // this is (diameter/intrinsicDiameter)^2

	double flux=0;
	for (int i=1; i<=nFacets; i++)
		flux+=FRMFacet(i, A2Sun, A2Earth, lambdaMu, rAU);
	flux*=factor;
	
	return flux;
}



void ConvexTriangulated::plotNEATMfitFileFRM(int n, double lambdaMu[], const char outname[], 
											 const eclipticVector &Sun2Aster, 
											 const eclipticVector &Earth2Aster, 
											 double JD) 
											 const
{
	double* fluxes =new double[n];
	FRMspectrum(n, lambdaMu, fluxes, Sun2Aster, Earth2Aster, JD);
	ofstream out(outname);

	out<<H<<endl;
	out<<G<<endl;
	out<<vector3::angle(Sun2Aster, Earth2Aster)<<endl;
	out<<Sun2Aster.getLength()<<endl;
	out<<Earth2Aster.getLength()<<endl;
	out<<n<<endl;
	for (int i=0; i<n; i++)
		out<<lambdaMu[i]<<'\t'<<fluxes[i]<<'\t'<<fluxes[i]/100.<<endl;

	out.close();

	delete [] fluxes;
}


double ConvexTriangulated::planckXU(double X, double u4) const
{
//	if (u4<=0 || X<=0)
//		throw invalid_argument("ConvexTriangulated::planckXU");

	// BAUSTELLE: might be speeded up by Taylor series for different domains of X/u4???	
	if (u4<= 1e-5) // prevent overflow
		return 0;
	double u=sqrt(sqrt(u4));
	return 1./ (exp(X/u)-1);
}



// uses LagerrosLookedup!
double ConvexTriangulated::LagFluxLookedup(const eclipticVector &Sun2Aster, const eclipticVector &Earth2Aster, 
									       double JD, double lambdaMu, double openingAngle) const
{
	vector3 A2Sun = bodyFix(Sun2Aster, JD);
	A2Sun *= -1;
	vector3 A2Earth = bodyFix(Earth2Aster, JD);
	A2Earth *= -1;
	double rAU=Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	return LagFluxLookedup(A2Sun, A2Earth, lambdaMu, rAU, deltaKM, openingAngle);
}// ConvexTriangulated::LagFluxLookedup



double ConvexTriangulated::LagFluxLookedup(const vector3 &A2Sun, const vector3 &A2Earth, 
									       double lambdaMu, double rAU, double deltaKM, double openingAngle) const
{
	if (openingAngle == 0)
		return LambertFlux(A2Sun, A2Earth, lambdaMu, rAU, deltaKM);

	double factor = 2*AsteroidConstants::hc2*emissivity/(pow(deltaKM,2)*pow(lambdaMu, 5));
	factor *= pow(scaleFactor, 2);

	// blueness = wavelength * subsolar temperature (K*mu)
	LagerrosLookedup crater (openingAngle, lambdaMu*TSS(rAU));

	double flux=0;
	double correction;
	for (int i=1; i<=nFacets; i++)
	{
//		try {
//		if (i==5249)
//			int x=12;
		correction = crater.CorrectionFactor(facets[i]->getDA(), A2Earth, A2Sun);
//		} catch (...)
//		{
//			cerr<<i<<endl;
//			throw;
//		};
		if (correction > 0)
			flux += correction* LambertFacet(i, A2Sun, A2Earth, lambdaMu, rAU);
	}
	flux *=factor;
	return flux;
} // ConvexTriangulated::LagFluxLookedup



void ConvexTriangulated::outputFluxes(const char outName[], 
									  const fitFile &ephemerides, 
									  unsigned int nOpeningAngles, const double openingAngles[], 
									  double accuracy) const
{
	//this->setPV(pV);
	ofstream out(outName);
	if (!out)
		throw invalid_argument ("Couldn't open file for writing!");
	const double nRecords = ephemerides.nRecords;

	out<<"# Generated by ConvexTriangulated::outputFluxes"<<endl;
	out<<"# pv="<<this->pV<<", #data points="<<ephemerides.nRecords<<", #opening angles="<<nOpeningAngles<<endl;
	out<<"# format: opening angle (deg) followed by #datapoints rows with each:"<<endl;
	out<<"# JD \t lambda(microns) \t thermal flux (W/m^2/mu)"<<endl;
	out<<pV<<"\t"<<nRecords<<"\t"<<nOpeningAngles<<endl;
	out<<endl;

	for (int i=0; i<nOpeningAngles; i++)
	{
		const double gamma=openingAngles[i];
		out<<fixed<<gamma<<endl;
		for (int j=0; j<nRecords; j++)
		{
			const fluxRecord& record = ephemerides[j];
			out<<"\t\t"<<fixed<<record.JD<<"\t"<<record.lambdaMu<<"\t";
			out<<scientific<<LagFluxLookedup(record.Sun2Aster, record.Earth2Aster, record.JD, record.lambdaMu, gamma, accuracy)
				<<endl;
		};
		out<<endl;
	};
}; // ConvexTriangulated::outputFluxes



void ConvexTriangulated::calculateChiSquared(const fitFile &data, const char modelFluxes[], const char outName[])
{
	double* flat=0, *cratered=0;
//	try
//	{
		ifstream in(modelFluxes);
		if (!in)
			throw invalid_argument ("Couldn't open file containing model fluxes for reading!");
		while (in.peek() == '#')
		{
			char dummy[256];
			in.getline(dummy, 255);
		};
		double pv, nRecords, nOpeningAngles;
		in>>pv>>nRecords>>nOpeningAngles;
		if (!in)
			throw invalid_argument ("File containing model fluxes malformatted!");
		if (nRecords != data.nRecords)
			throw invalid_argument ("Mismatch between data and model fluxes: Number of records must be identical!");
		
		flat = new double[nRecords];
		cratered = new double [nRecords];

		ofstream out(outName);
		if (!out)
			throw invalid_argument("Couldn't read output file for writing!");

		out<<"# Fitting cratered model fluxes to measured ones."<<endl;
		out<<"# Source for model fluxes: "<<modelFluxes<<endl;
		out<<"#"<<endl;
		out<<"# Format of the following lines:"<<endl;
		out<<"# pv / opening angle (deg) / best fit crater density / Chi squared"<<endl;
		out<<"# For calculating chi^2, the density is cropped to values between zero and one."<<endl;
		out<<endl;
		
		double gamma; // craters' opening angle in degrees
		in>>gamma;
		if (gamma!=0)
			throw invalid_argument("File containing model fluxes malformatted!");

		double JD, lambda;
		int i;
		for (i=0; i<nRecords; i++)
		{
			const fluxRecord& record = data[i];
			in>>JD>>lambda>>flat[i];
			if (!in)
				throw invalid_argument("File containing model fluxes malformatted!");
			if ( fabs(JD/record.JD - 1) > 1e-3) // fuzzy boundary -- means: JD != record.JD
				throw invalid_argument ("Mismatch between data and model fluxes: Julian dates");
			if ( fabs(lambda/record.lambdaMu - 1) > 1e-3)
				throw invalid_argument ("Mismatch between data and model fluxes: wave lengths");
		}; // done reading in 'flat' fluxes

		// output first: chisquared without craters
		{
			double chi2=0;
			for (int j=0; j<nRecords; j++)
				chi2+= pow( (flat[j]-data[j].fluxSI)/data[j].sigmaSI, 2);
			out<<showpoint<<pv<<"\t0\t0\t"<<chi2<<endl;
		};

		for (i=1; i<nOpeningAngles; i++)
		{
			in>>gamma;
			int j;
			for (j=0; j<nRecords; j++)
			{
				const fluxRecord& record = data[j];
				in>>JD>>lambda>>cratered[j];
				if (!in)
					throw invalid_argument("File containing model fluxes malformatted!");
				if ( fabs(JD/record.JD - 1) > 1e-3)
					throw invalid_argument ("Mismatch between data and model fluxes: Julian dates");
				if ( fabs(lambda/record.lambdaMu - 1) > 1e-3)
					throw invalid_argument ("Mismatch between data and model fluxes: wave lengths");
			} // done reading in cratered fluxes -> start calculating best fit crater density

			double oben=0, unten=0;
			// auxiliary variables for calculating the best fit crater density
			for (j=0; j<nRecords; j++)
			{
				oben -= (flat[j]-data[j].fluxSI) * (cratered[j]-flat[j]) / pow(data[j].sigmaSI,2);
				unten+= pow ( (cratered[j]-flat[j])/data[j].sigmaSI, 2);
			};
			if (unten==0)
				throw logic_error("");
			double craterDensity=oben/unten;

			double rho; // best fit crater density, may be 0 or 1
			if (craterDensity<0)
				rho=0;
			else
			{
				if(craterDensity>1)
					rho=1;
				else 
					rho=craterDensity;
			};
			
			double chi2=0;
			for (j=0; j<nRecords; j++)
				chi2+= pow( (rho*cratered[j] + (1-rho)*flat[j] - data[j].fluxSI)/data[j].sigmaSI, 2);
			out<<showpoint<<pv<<"\t"<<gamma<<"\t"<<craterDensity<<"\t"<<chi2<<endl;
		}; // done!

		if (!in)
		{
			if (! in.eof())
				throw invalid_argument ("File containing model fluxes malformatted! (???)");
		};
		if (!out)
			throw invalid_argument ("Something went wrong while writing output to file! (???)");
		out.close();

		delete[] flat;
		delete[] cratered;
/*	}
	catch(...)
	{	
		delete[] flat;
		delete[] cratered;
		throw;
	};
*/
}  //ConvexTriangulated::calculateChiSquared



double ConvexTriangulated::NEATMFacet(int facet, const vector3 &A2Sun, const vector3 &A2Earth, 
									  double lambdaMu, double rAU, double eta) const
{
	const double EPS = 1e-8; // to prevent numeric under/overflow
	const vector3& normal = facets[facet]->getDA();
	double area=normal.modulus();
	if(area==0)
		return 0;
	const vector3 unitNormal = normal/area;

	double cosSun=vector3::dot(A2Sun, unitNormal);
	if (cosSun<EPS)
		return 0; // dA isn't illuminated
	double cosEarth=vector3::dot(A2Earth, unitNormal);
	if (cosEarth<EPS)
		return 0; // dA invisible from Earth

	double T=TSS(rAU, cosSun, eta);		
	double flux=area*cosEarth;
	flux /= (exp(AsteroidConstants::hck/(lambdaMu*T) ) - 1);
	return flux;
}; //ConvexTriangulated::NEATMFacet



// BAUSTELLE: add JD!
void ConvexTriangulated::plotThermalLag  (const char* const filename,
								  const eclipticVector& Sun2Aster,
								  const eclipticVector& Earth2Aster,
								  double lambdaMu, // wavelength in microns
								  double openingAngle, // opening angle of hemisphere's segments (deg)
								  double craterDensity, // 0<=craterDensity<=1
								  const unsigned int plotPoints,
								  unsigned int periods) // =40
								  const
								  throw (invalid_argument)
{
	if (plotPoints<2)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: there must be at least 2 plotPoints!");
	if (craterDensity<0)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: negative crater density!");
	if (craterDensity>1)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: crater density > 1!");
	if (openingAngle<=0)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: openingAngle <= 0!");
	if (openingAngle>180)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: openingAngle > 180!");
	ofstream out (filename);
	if (!out)
		throw invalid_argument("Error in ConvexTriangulated::plotThermalLag: Cannot open file for writing (?)");

	double step = periods/(plotPoints-1.);
	vector3 A2Sun   = bodyFix(Sun2Aster);
	A2Sun *= -1;
	// unit vector pointing away from asteroid

	vector3 A2Earth = bodyFix(Earth2Aster);
	A2Earth *= -1;

	double rAU= Sun2Aster.getLength();
	double deltaKM=Earth2Aster.getLength()*AsteroidConstants::AU;

	out<<"# Thermal lightcurve generated by ConvexTriangulated::plotThermalLag"<<endl;
	out<<"# 1st row: time/h (arbitrary offset)"<<endl;
	out<<"# 2nd row: wavelength in microns"<<endl;
	out<<"# 3rd row: flux in W/m^2/mu"<<endl;
	out<<"# 4th row: flux in mJy"<<endl;
	
	double phase = 0;
	double flux;
	double timestep=step*period;
	for (unsigned int i=0; i<plotPoints; i++)
	{
		flux = craterDensity * LagFluxLookedup(A2Sun, A2Earth, lambdaMu, rAU, deltaKM, openingAngle)
			+ (1-craterDensity)*LambertFlux(A2Sun, A2Earth, lambdaMu, rAU, deltaKM);
		out.setf(ios::scientific);
		out.setf(ios::fixed); out.width(10);
		out<<phase*period<<"\t";
		out.setf(ios::fixed); out.width(7);
		out<<lambdaMu<<"\t";
		out.setf(ios::scientific); out.width(10);
		out<<flux<<"\t";
		out.setf(ios::fixed); out.width(7);
		out<<jansky::SI2mJy(flux, lambdaMu)<<'\n';

		spin(A2Sun, timestep);
		spin(A2Earth, timestep);
		phase+=step;
	}; 
}; // ConvexTriangulated::plotThermalLag




